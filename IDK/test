<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rozdělení adresního rozsahu</title>
    <style>
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid black;
            padding: 8px;
            text-align: left;
        }
        .network {
            color: green;
            font-weight: bold;
        }
        .host-bits {
            color: red;
            font-weight: bold;
        }
        .broadcast {
            color: blue;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <h1>Rozdělení adresního rozsahu</h1>
    <label for="range">Zadejte rozsah adres (např. 128.20.0.0/23):</label>
    <input type="text" id="range" name="range" value="172.16.0.0/16">
    <br>
    <label for="subnets">Zadejte počet hostů pro jednotlivé podsítě (oddělené čárkou, např. 200,120,60,4,2):</label>
    <input type="text" id="subnets" name="subnets" value="2000,600,500,6,4">
    <button onclick="splitRange()">Rozdělit</button>

    <table id="resultTable">
        <thead>
            <tr>
                <th>Subnet</th>
                <th>Počet hostů</th>
                <th>Adresa sítě</th>
                <th>Broadcast</th>
                <th>Prefix</th>
            </tr>
        </thead>
        <tbody>
            <!-- Výsledky budou zde -->
        </tbody>
    </table>

    <h2>Postup výpočtu</h2>
    <div id="calculationSteps">
        <!-- Kroky postupu budou zde -->
    </div>

    <script>
        function splitRange() {
            const range = document.getElementById('range').value;
            const [baseAddress, basePrefix] = range.split('/');
            const subnetsInput = document.getElementById('subnets').value;
            const subnets = subnetsInput.split(',').map(hosts => {
                const prefix = 32 - Math.ceil(Math.log2(parseInt(hosts) + 2));
                return { hosts: parseInt(hosts), prefix: prefix };
            });

            const resultTable = document.getElementById('resultTable').getElementsByTagName('tbody')[0];
            const calculationSteps = document.getElementById('calculationSteps');

            if (!resultTable || !calculationSteps) {
                console.error("Elementy resultTable nebo calculationSteps nebyly nalezeny.");
                return; // Vyskočte z funkce, pokud elementy nejsou nalezeny
            }

            resultTable.innerHTML = '';
            calculationSteps.innerHTML = '';

            let currentAddress = baseAddress;

            subnets.forEach((subnet, index) => {
                const row = resultTable.insertRow();
                const subnetLabel = `Subnet ${String.fromCharCode(65 + index)}`;
                const broadcastAddress = calculateBroadcast(currentAddress, subnet.prefix);

                row.insertCell(0).innerText = subnetLabel;
                row.insertCell(1).innerText = subnet.hosts;
                row.insertCell(2).innerText = currentAddress;
                row.insertCell(3).innerText = broadcastAddress;
                row.insertCell(4).innerText = `/${subnet.prefix}`;

                addCalculationStep(subnetLabel, subnet.hosts, currentAddress, broadcastAddress, subnet.prefix);

                currentAddress = getNextAddress(currentAddress, subnet.prefix);
            });
        }

        function calculateBroadcast(address, prefix) {
            const [octet1, octet2, octet3, octet4] = address.split('.').map(Number);
            const hostBits = 32 - prefix;
            const broadcastAddress = (octet1 << 24) | (octet2 << 16) | (octet3 << 8) | octet4 | ((1 << hostBits) - 1);
            return [
                (broadcastAddress >> 24) & 255,
                (broadcastAddress >> 16) & 255,
                (broadcastAddress >> 8) & 255,
                broadcastAddress & 255
            ].join('.');
        }

        function getNextAddress(address, prefix) {
            const [octet1, octet2, octet3, octet4] = address.split('.').map(Number);
            const hostBits = 32 - prefix;
            const nextAddress = ((octet1 << 24) | (octet2 << 16) | (octet3 << 8) | octet4) + (1 << hostBits);
            return [
                (nextAddress >> 24) & 255,
                (nextAddress >> 16) & 255,
                (nextAddress >> 8) & 255,
                nextAddress & 255
            ].join('.');
        }

        function addCalculationStep(subnetLabel, hosts, networkAddress, broadcastAddress, prefix) {
            const stepDiv = document.createElement('div');
            const hostBits = 32 - prefix;
            const maxHosts = (1 << hostBits) - 2;

            stepDiv.innerHTML = `
                <h3>${subnetLabel}</h3>
                <p>Počet hostů: ${hosts}</p>
                <p>Výpočet požadovaného prefixu:</p>
                <ul>
                    <li>Potřebujeme minimálně ${hosts} hostů.</li>
                    <li>Přičítáme 2 (pro adresu sítě a broadcast) => požadováno ${hosts + 2} adres.</li>
                    <li>Logaritmus o základu 2 z počtu adres: log2(${hosts + 2}) = ${Math.log2(hosts + 2).toFixed(2)}</li>
                    <li>Zaokrouhlujeme nahoru: ${Math.ceil(Math.log2(hosts + 2))} bitů pro hosty.</li>
                    <li>Prefix = 32 - ${Math.ceil(Math.log2(hosts + 2))} = ${prefix}</li>
                </ul>
                <p>Výpočet jednotlivých prvků:</p>
                <ul>
                    <li>Adresa sítě: <span class="network">${networkAddress}</span> (${ipToBinary(networkAddress)})</li>
                    <li>Počet bitů pro hosty: <span class="host-bits">${hostBits}</span> (umožňuje až ${maxHosts} hostů)</li>
                    <li>Broadcast adresa: <span class="broadcast">${broadcastAddress}</span> (${ipToBinary(broadcastAddress)})</li>
                    <li>Počáteční adresa pro další subnet: ${getNextAddress(networkAddress, prefix)}</li>
                </ul>
            `;
            document.getElementById('calculationSteps').appendChild(stepDiv);
        }

        function ipToBinary(ip) {
            return ip.split('.')
                .map(octet => parseInt(octet).toString(2).padStart(8, '0'))
                .join('.');
        }
    </script>
</body>
</html>
